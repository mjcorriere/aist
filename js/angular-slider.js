// Generated by CoffeeScript 1.7.1
(function() {
  var MODULE_NAME, SLIDER_TAG, angularize, gap, halfWidth, hide, inputEvents, module, offset, offsetLeft, pixelize, qualifiedDirectiveDefinition, roundStep, show, sliderDirective, width;

  MODULE_NAME = 'ui.slider';

  SLIDER_TAG = 'slider';

  angularize = function(element) {
    return angular.element(element);
  };

  pixelize = function(position) {
    return "" + position + "px";
  };

  hide = function(element) {
    return element.css({
      opacity: 0
    });
  };

  show = function(element) {
    return element.css({
      opacity: 1
    });
  };

  offset = function(element, position) {
    return element.css({
      left: position
    });
  };

  halfWidth = function(element) {
    return element[0].offsetWidth / 2;
  };

  offsetLeft = function(element) {
    return element[0].offsetLeft;
  };

  width = function(element) {
    return element[0].offsetWidth;
  };

  gap = function(element1, element2) {
    return offsetLeft(element2) - offsetLeft(element1) - width(element1);
  };

  bindHtml = function(element, html) {
    // return element.attr('ng-bind-html', html + ' | unsafe');
    return element.attr('ng-bind-html', html);
  }

  roundStep = function(value, precision, step, floor) {
    var decimals, remainder, roundedValue, steppedValue;
    if (floor == null) {
      floor = 0;
    }
    if (step == null) {
      step = 1 / Math.pow(10, precision);
    }
    remainder = (value - floor) % step;
    steppedValue = remainder > (step / 2) ? value + step - remainder : value - remainder;
    decimals = Math.pow(10, precision);
    roundedValue = steppedValue * decimals / decimals;
    return roundedValue.toFixed(precision);
  };

  inputEvents = {
    mouse: {
      start: 'mousedown',
      move: 'mousemove',
      end: 'mouseup'
    },
    touch: {
      start: 'touchstart',
      move: 'touchmove',
      end: 'touchend'
    }
  };

  sliderDirective = function($timeout, $sce) {
    return {
      restrict: 'E',
      scope: {
        floor: '@',
        ceiling: '@',
        values: '=?',
        range: '@',
        tri: '@',
        step: '@',
        highlight: '@',
        precision: '@',
        buffer: '@',
        dragstop: '@',
        ngModel: '=?',
        ngModelLow: '=?',
        ngModelHigh: '=?',
        ngModelMid: '=?',
        translate: '&',
        redraw: '&',
        isDirty: '=?'
      },
      template: '<div class="bar"><div class="selection"></div></div>\n<div class="handle low"></div><div class="handle high"></div>\n<div class="bubble limit low" ng-bind-html="translate({value: floor})"></div>\n<div class="bubble limit high" ng-bind-html="translate({value: ceiling})"></div>\n<div class="bubble value low"></div>\n<div class="bubble value high"></div><div class="handle mid"></div><div class="bubble value mid"></div>',

        // <div class="bar">
        //   <div class="selection"></div>
        // </div>
        // <div class="handle low"></div>
        // <div class="handle high"></div>
        // <div class="bubble limit low">
        //   {{ values.length ? ( values[floor || 0] || floor ) : floor }}
        // </div>
        // <div class="bubble limit high">
        //   {{ values.length ? ( values[ceiling || values.length - 1] || ceiling ) : ceiling }}
        // </div>
        // <div class="bubble value low">
        //   {{ values.length ? ( values[local.ngModelLow || local.ngModel] || local.ngModelLow || local.ngModel ) : local.ngModelLow || local.ngModel}}
        // </div>
        // <div class="bubble value high">
        //   {{ values.length ? ( values[local.ngModelHigh] || local.ngModelHigh ) : local.ngModelHigh }}
        // </div>
        // <div class="handle mid"></div>
        // <div class="bubble value mid">
        //   {{ values.length ? ( values[local.ngModelMid] || local.ngModelMid ) : local.ngModelMid }}
        // </div>

        // <div class="bubble value mid">
        //   
        // </div>        

      compile: function(element, attributes) {
        var bar,
          ceilBub,
          e,
          flrBub,
          high,
          highBub,
          low,
          lowBub,
          mid,
          midBub,
          maxPtr,
          minPtr,
          midPtr,
          range,
          tri,
          selection,
          watchables,
          _i,
          _len,
          _ref,
          _ref1;

        if (attributes.translate) {
          attributes.$set("translate", "" + attributes.translate + "(value)");
        }

        if (attributes.redraw) {
          attributes.$set("redraw", "" + attributes.redraw + "()");
        }

        range = (attributes.ngModel == null) && (attributes.ngModelLow != null) && (attributes.ngModelHigh != null) && (attributes.ngModelMid == null);
        tri   = (attributes.ngModel == null) && (attributes.ngModelLow != null) && (attributes.ngModelHigh != null) && (attributes.ngModelMid != null);
       
        _ref = (function() {
            var _i, _len, _ref, _results;
            _ref = element.children();
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              e = _ref[_i];
              _results.push(angularize(e));
            }
            return _results;

          })(), 
          
          bar     = _ref[0], 
          minPtr  = _ref[1], 
          maxPtr  = _ref[2], 
          flrBub  = _ref[3], 
          ceilBub = _ref[4], 
          lowBub  = _ref[5], 
          highBub = _ref[6],
          midPtr  = _ref[7],
          midBub  = _ref[8];

          
        
        low = (range || tri) ? 'ngModelLow' : 'ngModel';
        high = 'ngModelHigh';
        mid = 'ngModelMid';

        
        // {
        bindHtml(lowBub, "translate({value: " + low + "})");
        bindHtml(highBub, "translate({value: " + high + "})");
        bindHtml(midBub, "translate({value: " + mid + "})");
        // }

        selection = angularize(bar.children()[0]);

        if (!range && !tri) {
          _ref1 = [maxPtr, highBub, midPtr, midBub];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            element = _ref1[_i];
            element.remove();
          }
          if (!attributes.highlight) {
            selection.remove();
          }
        } else if (!tri) {
          _ref1 = [midPtr, midBub];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            element = _ref1[_i];
            element.remove();
          }
        }

        watchables = ['floor', 'ceiling', 'values', low];
        if (range) {
          watchables.push(high);
        }
        // {
        if (tri) {
          watchables.push(high, mid);
        }
        // }

        return {
          post: function(scope, element, attributes) {
            var barWidth, 
              boundToInputs,
              dimensions,
              endHandleHalfWidth,
              midHandleHalfWidth,
              maxOffset,
              maxValue,
              minOffset,
              minValue,
              midOffset,
              midValue,
              ngDocument,
              offsetRange,
              updateDOM,
              valueRange,
              w,
              _j,
              _len1;
            
            scope.local       = {};
            scope.local[low]  = scope[low];
            scope.local[high] = scope[high];
            scope.local[mid]  = scope[mid];
            boundToInputs     = false;
            
            ngDocument = angularize(document);

            if (!attributes.translate) {
              scope.translate = function(value) {
                return value.value.toString();
              };
            }

            endHandleHalfWidth = midHandleHalfWidth = barWidth = minOffset = maxOffset = midOffset = minValue = maxValue = midValue = valueRange = offsetRange = 0;

            dimensions = function() {

              if (tri) {
              } else if (range) {
              }
              var value, _j, _len1, _ref2;
              if (scope.step == null) {
                scope.step = 1;
              }
              if (scope.floor == null) {
                scope.floor = 0;
              }
              if (scope.precision == null) {
                scope.precision = 0;
              }
              // { Partial add: && !tri}
              if (!range && !tri) {
                scope.ngModelLow = scope.ngModel;
              }
              
              if ((_ref2 = scope.values) != null ? _ref2.length : void 0) {
                if (scope.ceiling == null) {
                  scope.ceiling = scope.values.length - 1;
                }
              }

              scope.local[low]  = scope[low];
              scope.local[high] = scope[high];
              
              // {
              scope.local[mid]  = scope[mid];
              // }
              
              for (_j = 0, _len1 = watchables.length; _j < _len1; _j++) {
                value = watchables[_j];
                if (typeof value === 'number') {
                  scope[value] = roundStep(parseFloat(scope[value]), parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor));
                }
              }
              
              endHandleHalfWidth = halfWidth(minPtr);
              midHandleHalfWidth = halfWidth(midPtr);
              barWidth = width(bar);
              minOffset = 0;
              maxOffset = barWidth - width(minPtr);
              minValue = parseFloat(scope.floor);
              maxValue = parseFloat(scope.ceiling);
              valueRange = maxValue - minValue;

              var _low, _high, _min, _max;
              _low = parseInt(scope[low]);
              _min = parseInt(minValue);
              _high = parseInt(scope[high]);
              _max = parseInt(maxValue);

              if ((_low == _min) && (_high == _max)) {
                scope.isDirty = false;
              }              
              
              return offsetRange = maxOffset - minOffset;

            };

            updateDOM = function() {
              
              var bindToInputEvents,
                fitToBar,
                percentOffset,
                percentToOffset,
                percentValue,
                setBindings,
                setPointers;
              
              dimensions();
              
              percentOffset = function(offset) {
                return ((offset - minOffset) / offsetRange) * 100;
              };
              
              percentValue = function(value) {
                return ((value - minValue) / valueRange) * 100;
              };
              
              percentToOffset = function(percent) {
                return pixelize(percent * offsetRange / 100);
              };
              
              fitToBar = function(element) {
                return offset(element,
                  pixelize(Math.min(Math.max(0, offsetLeft(element)), barWidth - width(element))));
              };
              
              setPointers = function() {
                var newHighValue, newLowValue, newMidValue;
                
                // 1.75 and 2.5 are magic numbers that position the label
                offset(ceilBub, pixelize(barWidth - width(ceilBub) / 1.75));
                offset(flrBub, pixelize(- width(flrBub) / 2.5));
                
                newLowValue = percentValue(scope.local[low]);
                
                offset(minPtr, percentToOffset(newLowValue));
                offset(lowBub, pixelize(offsetLeft(minPtr) - (halfWidth(lowBub)) + endHandleHalfWidth));
                offset(selection, pixelize(offsetLeft(minPtr) + endHandleHalfWidth));
                
                switch (true) {
                
                  case range:
                    newHighValue = percentValue(scope.local[high]);
                    offset(maxPtr, percentToOffset(newHighValue));
                    offset(highBub, pixelize(offsetLeft(maxPtr) - (halfWidth(highBub)) + endHandleHalfWidth));
                    return selection.css({
                      width: percentToOffset(newHighValue - newLowValue)
                    });
                
                  // {
                  case tri:

                    newHighValue = percentValue(scope.local[high]);
                    offset(maxPtr, percentToOffset(newHighValue));
                    offset(highBub, pixelize(offsetLeft(maxPtr) - (halfWidth(highBub)) + endHandleHalfWidth));
                    
                    newMidValue  = percentValue(scope.local[mid]);
                    offset(midPtr, percentToOffset(newMidValue));
                    offset(midBub, pixelize(offsetLeft(midPtr) - (halfWidth(midBub)) + midHandleHalfWidth));

                    return selection.css({
                      width: percentToOffset(newHighValue - newLowValue)
                    });
                  // }

                  case attributes.highlight === 'right':
                    return selection.css({
                      width: percentToOffset(110 - newLowValue)
                    });
                  case attributes.highlight === 'left':
                    selection.css({
                      width: percentToOffset(newLowValue)
                    });
                    return offset(selection, 0);
                }
              };
              
              bindToInputEvents = function(handle, bubble, ref, events) {
                var currentRef, onEnd, onMove, onStart;
                currentRef = ref;
                
                onEnd = function() {
                  bubble.removeClass('active');
                  handle.removeClass('active');
                  ngDocument.unbind(events.move);
                  ngDocument.unbind(events.end);
                  if (scope.dragstop) {
                    scope[high] = scope.local[high];
                    scope[low] = scope.local[low];
                    scope[mid] = scope.local[mid];
                  }
                  return currentRef = ref;
                };
                
                onMove = function(event) {
                  var eventX, newOffset, newPercent, newValue, currentHigh, currentLow, currentMid, buffer;
                
                  eventX = event.clientX || event.touches[0].clientX;
                
                  newOffset = eventX - element[0].getBoundingClientRect().left - endHandleHalfWidth;
                  newOffset = Math.max(Math.min(newOffset, maxOffset), minOffset);
                
                  newPercent = percentOffset(newOffset);
                  newValue = minValue + (valueRange * newPercent / 100.0);

                  // {
                  currentHigh = parseInt(scope.local[high]);
                  currentLow  = parseInt(scope.local[low]);
                  currentMid  = parseInt(scope.local[mid]);
                  buffer      = parseInt(scope.buffer);
                  // }
                
                  if (range) {
                    switch (currentRef) {
                      case low:

                        if (newValue > currentHigh) {
                          currentRef = high;
                          minPtr.removeClass('active');
                          lowBub.removeClass('active');
                          maxPtr.addClass('active');
                          highBub.addClass('active');
                          setPointers();
                        } else if (scope.buffer > 0) {
                          newValue = Math.min(newValue, currentHigh - buffer);
                        }
                        break;
                      case high:
                        if (newValue < currentLow) {
                          currentRef = low;
                          maxPtr.removeClass('active');
                          highBub.removeClass('active');
                          minPtr.addClass('active');
                          lowBub.addClass('active');
                          setPointers();
                        } else if (scope.buffer > 0) {
                          newValue = Math.max(newValue, currentLow + buffer);
                        }
                    }
                  }

                  if (tri) {
                    
                    switch (currentRef) {
                    
                      case low:
                        scope.isDirty = true;
                        if (newValue > currentHigh) {
                          currentRef = high;
                          minPtr.removeClass('active');
                          lowBub.removeClass('active');
                          maxPtr.addClass('active');
                          highBub.addClass('active');
                          setPointers();
                        } else if (scope.buffer > 0) {
                          newValue = Math.min(newValue, currentMid - buffer);
                        }
                        break;
                    
                      case high:
                        scope.isDirty = true;
                        if (newValue < currentLow) {
                          currentRef = low;
                          maxPtr.removeClass('active');
                          highBub.removeClass('active');
                          minPtr.addClass('active');
                          lowBub.addClass('active');
                          setPointers();
                        } else if (scope.buffer > 0) {
                          newValue = Math.max(newValue, currentMid + buffer);
                        }
                        break;
                    
                      case mid:

                        buffer = (parseInt(scope.buffer) > 0) ? parseInt(scope.buffer) : 1;

                        if (newValue > (currentHigh - buffer)) {
                          newValue = currentMid;
                        } else if (newValue < (currentLow + buffer)) {
                          newValue = currentMid;
                        }                        
                        
                        break;

                    }
                  }

                  newValue = roundStep(newValue, parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor));
                  scope.local[currentRef] = newValue;
                  if (!scope.dragstop) {
                    scope[currentRef] = newValue;
                  }
                  setPointers();
                  scope.redraw();
                  return scope.$apply();
                };
                
                onStart = function(event) {
                  dimensions();
                  bubble.addClass('active');
                  handle.addClass('active');
                  setPointers();
                  event.stopPropagation();
                  event.preventDefault();
                  ngDocument.bind(events.move, onMove);
                  return ngDocument.bind(events.end, onEnd);
                };
                
                return handle.bind(events.start, onStart);
              
              };
              
              setBindings = function() {
                var bind, inputMethod, _j, _len1, _ref2, _results;
                boundToInputs = true;
                bind = function(method) {
                  bindToInputEvents(minPtr, lowBub, low, inputEvents[method]);
                  // {
                  bindToInputEvents(midPtr, midBub, mid, inputEvents[method]);
                  // }

                  return bindToInputEvents(maxPtr, highBub, high, inputEvents[method]);
                };
                _ref2 = ['touch', 'mouse'];
                _results = [];
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                  inputMethod = _ref2[_j];
                  _results.push(bind(inputMethod));
                }
                return _results;
              };
              
              if (!boundToInputs) {
                setBindings();
              }
              return setPointers();
            };
            
            $timeout(updateDOM);
            for (_j = 0, _len1 = watchables.length; _j < _len1; _j++) {
              w = watchables[_j];
              scope.$watch(w, updateDOM, true);
            }
            return window.addEventListener("resize", updateDOM);
          }
        };
      }
    };
  };

  qualifiedDirectiveDefinition = ['$timeout', '$sce', sliderDirective];

  module = function(window, angular) {
    return angular.module(MODULE_NAME, []).directive(SLIDER_TAG, qualifiedDirectiveDefinition);
  };

  module(window, window.angular);

}).call(this);
